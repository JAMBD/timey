<!DOCTYPE html>
<html>
<body>
<canvas id="myCanvas" width="100%" height="100%" style="border:0px;  position:absolute; ; bottom:0; right:0; left:0; top:0; margin:auto">
  Your browser does not support the HTML5 canvas tag.
</canvas>
<script>

class Block{
  constructor(x,y,width,height){
    this.x = x;
    this.y = y;
    this.height = height;
    this.width = width;
    this.stop_left = true;
    this.stop_right = true;
    this.stop_up = true;
    this.stop_down = true;
  }
  draw_pattern(pctx){
    pctx.beginPath();
    pctx.moveTo(0,0);
    pctx.lineTo(5,5);
    pctx.moveTo(5,0);
    pctx.lineTo(0,5);
    pctx.stroke();
  }
  draw(ctx){
    var pattern = document.createElement("canvas");
    pattern.width = 5;
    pattern.height = 5;
    var pctx = pattern.getContext("2d");
    pctx.strokeStyle = ctx.strokeStyle;
    this.draw_pattern(pctx);
    ctx.fillStyle = ctx.createPattern(pattern,"repeat");
    ctx.fillRect(this.x-this.width/2,this.y-this.height/2,this.width,this.height);
    ctx.strokeRect(this.x-this.width/2,this.y-this.height/2,this.width,this.height);
  }
  validate_movement(player){
    if (Math.abs(player.x - this.x) < player.rad + this.width/2){
      if (Math.abs(player.y - this.y) < player.rad + this.height/2){
        if(Math.abs(player.x - this.x) < this.width/2 + player.rad-1){
          if(Math.abs((this.y-this.height/2)-player.y) < player.rad && this.stop_down){
            player.y = this.y - this.height/2 - player.rad;
            player.v_y = 0;
            player.is_floor = true;
          }
          if(Math.abs((this.y+this.height/2)-player.y) < player.rad && this.stop_up){
            player.y = this.y + this.height/2 + player.rad;
            player.v_y = 0;
          }
        }
        if(Math.abs(player.y - this.y) < this.height/2 + player.rad-1){
          if(Math.abs((this.x-this.width/2)-player.x) < player.rad && this.stop_right){
            player.x = this.x - this.width/2 - player.rad;
            player.v_x = -Math.abs(player.v_x) * 0.5;
          }
          if(Math.abs((this.x+this.width/2)-player.x) < player.rad && this.stop_left){
            player.x = this.x + this.width/2 + player.rad;
            player.v_x = Math.abs(player.v_x) * 0.5;
          }
        }
        if (Math.abs(player.x - this.x) < this.width/2){
          if (Math.abs(player.y - this.y) < this.height/2){
            if(this.stop_up && player.v_y < 0){
              player.y -= player.v_y;
              player.v_y = 0;
            }
            if(this.stop_down && player.v_y > 0){
              player.y -= player.v_y;
              player.v_y = 0;
            }
            if(this.stop_left && player.v_x < 0){
              player.x -= player.v_x;
              player.v_x = 0;
            }
            if(this.stop_right && player.v_x > 0){
              player.x -= player.v_x;
              player.v_x = 0;
            }
          }
        }
        return true;
      }
    }
    return false;
  }
}

class ClearBlock extends Block{
  constructor(x,y,width,height){
    super(x,y,width,height);
    this.stop_left = false;
    this.stop_right = false;
    this.stop_up = false;
    this.stop_down = false;
  }
  draw_pattern(pctx){
  }
}

class Player{
  constructor(){
    this.x = 100;
    this.y = 100;
    this.v_x = 0;
    this.v_y = 0;
    this.rad = 5;
    this.prev_time = 0;
    this.is_floor = false;
    this.history = [];
    this.key_down_array = [];
    this.start_time = 0;
  }
  draw(ctx){
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.rad, 0, 2 * Math.PI);
    ctx.stroke();
    ctx.fill();
  }
  del_action(e,level_time){
    this.history.push([0, level_time, e.keyCode])
  }

  add_action(e,level_time){
    this.history.push([1, level_time, e.keyCode])
  }

  perform_history(level_time){
    for(var i=0; i < this.history.length; i++){
      var entry = this.history[i];
      if(entry[1] < this.prev_time) continue;
      if(entry[1] > level_time) continue;
      if(entry[0] == 0){
        this.key_down_array = this.key_down_array.filter(function(v) { return v !== entry[2]});
      }else if(entry[0] == 1){
        switch(entry[2]){
          case 32:
            //space
            if(!this.key_down_array.includes(32)){
              this.jump();
            }
            break;
          case 38:
            //up
            if(!this.key_down_array.includes(38)){
              this.v_y -= 3;
            }
            break;
          case 40:
            //down
            break;
          case 39:
            //right
            break;
          case 37:
            //left
            break;
          default:
            //alert(entry[2]);
        }
        if(!this.key_down_array.includes(entry[2])){
          this.key_down_array.push(entry[2]);
        }
      }
    }
    this.prev_time = level_time;
  }

  jump(){
    if (this.is_floor){
      this.v_y -= 18;
    }
  }
  update(time){
    this.perform_history(time);
    for (var i in this.key_down_array){
      switch(this.key_down_array[i]){
        case 39:
          //right
          this.v_x += 0.5;
          break;
        case 37:
          //left
          this.v_x -= 0.5;
          break;
      }
    }
    if (Math.abs(this.v_x) > 3){
      if(this.v_x > 0){
        this.v_x = 3;
      }else{
        this.v_x = -3;
      }
    }
    this.v_x *= 0.900;
    this.v_y *= 0.900;
    this.v_y += 0.50;
    this.x += this.v_x;
    this.y += this.v_y;
    this.is_floor = false;
  }
}

class Level{
  constructor(end_block, start_block, time_limit){
    this.blocks = [];
    this.doors = [];
    this.buttons = [];
    this.start_block = start_block;
    this.end_block = end_block;
    this.time_limit = time_limit;
    this.cur_time = 0;
    this.try_count = 0;
    this.past_players = [];
    this.player = null;
    this.started = false;
    this.failed = false;
    this.complete = false;
  }
  reset(){
    this.player = new Player();
    this.cur_time = 0;
    this.past_players.push(this.player);
    for(var i in this.past_players){
      this.past_players[i].key_down_array = [];
    }
    this.player.start_time = this.try_count * 50;
    if(this.player.start_time > this.time_limit){
      this.failed = true;
    }
    this.try_count ++;
  }
  start(){
    this.started = true;
    this.reset();
  }
  add_action(e){
    if (this.player != null){
      this.player.add_action(e,this.cur_time);
    }
  }
  del_action(e){
    if (this.player != null){
      this.player.del_action(e,this.cur_time);
    }
  }
  update(){
    if(!this.started) return;
    if(this.failed) return;
    for(var i in this.past_players){
      var player = this.past_players[i];
      if(this.cur_time <= player.start_time){
        player.v_x = 0;
        player.v_y = 0;
        player.x = this.start_block.x;
        player.y = this.start_block.y;
      }
    }
    for (var i in this.past_players){
      this.past_players[i].update(this.cur_time);
    }
    this.hit_idx = [];
    for (var i in this.buttons){
      this.hit_idx.push(i);
    }
    for (var i in this.past_players){
      for (var j in this.buttons){
        if (this.buttons[j].validate_movement(this.past_players[i])){
          this.hit_idx = this.hit_idx.filter(function(v) { return v !== j});
        }
      }
    }
    for (var i in this.past_players){
      for (var j in this.hit_idx){
        this.doors[this.hit_idx[j]].validate_movement(this.past_players[i]);
      }
    }
    for (var i in this.past_players){
      for (var j in this.blocks){
        this.blocks[j].validate_movement(this.past_players[i]);
      }
      if(this.end_block.validate_movement(this.past_players[i])){
        this.complete = true;
      }
    }
    for (var i in this.past_players){
      for (var j in this.past_players){
        if (j > i){
          var p1 = this.past_players[i];
          var p2 = this.past_players[j];
          if(p1.start_time > this.cur_time) continue;
          if(p2.start_time > this.cur_time) continue;
          var dx = p1.x - p2.x;
          var dy = p1.y - p2.y;
          var dis2 = dx * dx + dy * dy;
          var pdist = p1.rad + p2.rad;
          if(pdist * pdist > dis2){
            this.failed = true;
          }
        }
      }
    }
    this.cur_time += 1;
    if(this.cur_time > this.time_limit){
      this.reset();
    }
  }
  draw(ctx){
    var colors = [
      "#F00",
      "#0F0",
      "#00F",
      "#FF0",
      "#0FF",
      "#F0F"];

    for (var j in this.hit_idx){
      ctx.strokeStyle = colors[j % colors.length];
      this.doors[this.hit_idx[j]].draw(ctx);
    }
    for (var i in this.buttons){
      ctx.strokeStyle = colors[i % colors.length];
      this.buttons[i].draw(ctx);
    }
    for (var i in this.blocks){
      ctx.strokeStyle = "#000";
      this.blocks[i].draw(ctx);
    }
    var per = this.cur_time / this.time_limit;
    ctx.fillStyle = "#000";
    if (this.cur_time < this.player.start_time){
      ctx.fillStyle = "#AAA";
    }
    ctx.beginPath();
    ctx.moveTo(30,30);
    ctx.arc(30,30,20,-0.5 * Math.PI,(2 * per -0.5) * Math.PI);
    ctx.fill();
    this.start_block.draw(ctx);
    this.end_block.draw(ctx);
    for (var i in this.past_players){
      ctx.fillStyle = "#000";
      if (i < this.past_players.length-1){
        ctx.fillStyle = "#AAA";
      }
      this.past_players[i].draw(ctx);
    }

  }
}

var cur_level = 0;
var level_switch_cnt = 0;
var level_switch = true;
var game_done = false;
var levels = [];

levels.push(new Level(new ClearBlock(100,275,10,10), new ClearBlock(500,230,10,10),300));
levels[0].blocks.push(new Block(100,250,100,15));
levels[0].blocks.push(new Block(57.5,275,15,65));
levels[0].blocks.push(new Block(window.innerWidth/2,300,window.innerWidth,20));
levels[0].doors.push(new Block(143.5,275,15,65));
levels[0].buttons.push(new ClearBlock(400,280,10,10));

levels.push(new Level(new ClearBlock(183.5,200,10,10), new ClearBlock(120,270,10,10),300));
levels[1].blocks.push(new Block(100,250,150,15));
levels[1].blocks.push(new Block(300,250,100,15));
levels[1].blocks.push(new Block(342.5,275,15,65));
levels[1].blocks.push(new Block(200,245,15,130));
levels[1].blocks.push(new Block(167.5,218,15,75.5));
levels[1].blocks.push(new Block(183.5,187.5,45.5,15));
levels[1].blocks.push(new Block(window.innerWidth/2,300,window.innerWidth,20));
levels[1].doors.push(new Block(167.5,275,15,65));
levels[1].doors.push(new Block(257.5,275,15,65));
levels[1].buttons.push(new ClearBlock(300,280,10,10));
levels[1].buttons.push(new ClearBlock(400,280,10,10));

function keyDownEvent(e){
  levels[cur_level].add_action(e);
}

function keyUpEvent(e){
  levels[cur_level].del_action(e);
}

function setup(){
  var c = document.getElementById("myCanvas");
  window.addEventListener('keydown', keyDownEvent, false);
  window.addEventListener('keyup', keyUpEvent, false);
  window.addEventListener('resize', resizeCanvas, false);
  c.width = window.innerWidth;
  c.height = window.innerHeight;
  setInterval(function() {
      update();
      draw();
      }, 30);
  resizeCanvas();
}

function draw(){
  var c = document.getElementById("myCanvas");
  var ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  ctx.fillStyle = "#FFF";
  ctx.fillRect(0,0,c.width,c.height);
  if(game_done){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle = "#0F0";
    ctx.fillText("GAME_COMPLETE",c.width/2,c.height/2);
  }else if(level_switch){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle = "#FFF";
    ctx.fillText("level",c.width/2,c.height/2);
  }else if(this.levels[this.cur_level].failed){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,c.width,c.height);
    ctx.fillStyle = "#F00";
    ctx.fillText("FAILED",c.width/2,c.height/2);
  }else{
    this.levels[this.cur_level].draw(ctx);
  }
}

function resizeCanvas(){
  var c = document.getElementById("myCanvas");
  min_len = Math.min(window.innerWidth,window.innerHeight);
  c.width = min_len;
  c.height = min_len;
  c.style.width = min_len + 'px';
  c.style.height = min_len + 'px';
  draw();
}

function update(){
  if(level_switch){
    if(level_switch_cnt > 0){
      level_switch_cnt --;
    }else{
      level_switch = false;
      levels[cur_level].start();
    }
  }
  if(cur_level == -1 || levels[cur_level].complete){
    level_switch = true;
    level_switch_cnt = 50;
    cur_level ++;
    if(cur_level >= levels.length){
      cur_level = 0;
      game_done = true;
    }
  }
  levels[cur_level].update();
}

setup();

</script>
</body>
</html>
